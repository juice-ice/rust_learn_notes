## 所有权规则

1. Rust的每个值都有一个所有者（owner）变量
2. 值在任何时刻有且只有一个所有者
3. 当所有者离开作用域，这个值被抛弃

## 内存与分配

```rust
{
    let s = String::from("hello")
} // 作用域结束
// s不再有效

```

当s离开作用域，Rust调用了一个特殊的`drop`函数，释放了内存

### 变量：移动

```rust
let y = 5;
let x = y;
```

现在有两个变量都为整数5，被放入栈中

```rust
let s1 = String::from("hello");
let s2 = s1;
```

为了避免`二次释放`的错误，Rust认为`s1`不再有效

这个操作称为`移动`，这个String堆内存被移动到了s2上，s1失效

### 变量：clone

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {},s2 = {}",s1 ,s2);
```

Rust有一个叫做`Copy`trait的特殊注解，可用在存储在栈上的类型上。

如果一个变量实现了`Copy`trait，那么当它复制给一个新变量后仍然可用。

Rust不允许自身或任何部分实现了`Drop`trait的类型使用`Copy`trait。

任何简单标量值都实现了`Copy`：

* 所有整数类型
* 布尔类型
* 浮点数类型
* 字符类型
* 仅包含`Copy`类型的元组
